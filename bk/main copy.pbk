#main.py
import os
import json
import pathlib
import shutil
import threading
import tkinter as tk
from tkinter import ttk
from tkinterdnd2 import DND_FILES, TkinterDnD
from osu import generate_osu_file
from get_info import get_info, get_names

output_base_path = 'output'  # 你可以根据需要修改输出文件夹路径

if not os.path.exists(output_base_path):
    os.makedirs(output_base_path)

def get_unique_filename(existing_path):
    base, extension = os.path.splitext(existing_path)
    counter = 1
    while os.path.exists(existing_path):
        existing_path = f"{base}_old_{counter}{extension}"
        counter += 1
    return existing_path

# 缓存字典
bmson_cache = {}

def process_folder(folder_path):
    bmson_file = None
    for filename in os.listdir(folder_path):
        if filename.endswith('.bmson'):
            bmson_file = os.path.join(folder_path, filename)
            bmson_file = os.path.normpath(bmson_file)  # 规范化路径
            break

    if bmson_file:
        print(f"Processing file: {bmson_file}")  # 打印路径以调试
        if not os.path.exists(bmson_file):
            print(f"Path does not exist: {bmson_file}")
            return
        
        try:
            with open(bmson_file, 'r') as file:
                data = json.load(file)
        except Exception as e:
            print(f"Error reading bmson file: {e}")
            return

        bmson_cache[bmson_file] = data
        bmson_file = bmson_cache[bmson_file]

        try:
            info_obj = get_info(data)
            names_obj = get_names(info_obj)
        except Exception as e:
            print(f"Error processing bmson data: {e}")
            return

        base_path = os.path.dirname(folder_path)
        output_base_path = os.path.join(base_path, names_obj.new_folder)
        sub_folder_path = os.path.join(output_base_path, names_obj.sub_folder)
        
        os.makedirs(output_base_path, exist_ok=True)
        os.makedirs(sub_folder_path, exist_ok=True)

        files = scan_folder(folder_path)

        # 复制媒体文件到新文件夹
        for file_path in files:
            if file_path.endswith(('.mp3', '.wav', '.ogg', '.jpg', '.png')):
                # 获取文件的基本名称
                base_name = os.path.basename(file_path)
                if file_path.endswith(('.jpg', '.png')):
                    mda_new_name = f"{info_obj.song}_{info_obj.diff}{os.path.splitext(base_name)[1]}"
                else:
                    mda_new_name = base_name
                destination_path = os.path.join(sub_folder_path, mda_new_name)
                
                # 检查目标文件夹中是否存在重名文件
                if os.path.exists(destination_path):
                    existing_path = get_unique_filename(destination_path)
                    os.rename(destination_path, existing_path)
                
                shutil.copy(file_path, destination_path)
            
            # 调用转换脚本生成 osu 文件内容
            osu_content = generate_osu_file(bmson_file)
            
            # 检查是否存在同名的 .osu 文件
            osu_file_path = os.path.join(sub_folder_path, names_obj.osu_filename)
            if os.path.exists(osu_file_path):
                base, ext = os.path.splitext(names_obj.osu_filename)
                counter = 1
                old_osu_filename = f"{base}_old{counter}{ext}"
                while os.path.exists(os.path.join(sub_folder_path, old_osu_filename)):
                    counter += 1
                    old_osu_filename = f"{base}_old{counter}{ext}"
                # 重命名已有的 .osu 文件
                os.rename(osu_file_path, os.path.join(sub_folder_path, old_osu_filename))

            # 写入 osu 文件
            with open(osu_file_path, 'w') as file:
                file.write(osu_content)

    else:
        print("文件夹中没有要转换的文件")

def scan_folder(folder_path):
    files = []
    folder_path = os.path.normpath(folder_path)  # 规范化路径
    for root, _, filenames in os.walk(folder_path):
        root = os.path.normpath(root)  # 规范化路径
        for filename in filenames:
            file_path = os.path.join(root, filename)
            file_path = os.path.normpath(file_path)  # 规范化路径
            if os.path.isfile(file_path):
                files.append(file_path)
    return files

def on_drop(event):
    files_lst = []  
    paths = root.tk.splitlist(event.data)
    
    def process_file(file, semaphore):  
        with semaphore:
            try:
                process_folder(file)
            except Exception as e:
                print(f"处理文件 {file} 时发生错误: {e}")
    
    for path in paths:
        path = pathlib.Path(path)
        if path.exists():
            if path.is_file():
                if path.suffix == '.bmson':
                    files_lst.append(str(path))
            elif path.is_dir():
                for root_dir, dirs, files in os.walk(path):
                    root_dir = pathlib.Path(root_dir)
                    for name in files:
                        file_path = root_dir / name
                        if file_path.suffix == '.bmson':
                            files_lst.append(str(file_path))
    
    semaphore = threading.BoundedSemaphore(value=min(len(files_lst), os.cpu_count() + 4, 10))
    threads = []
    for file in files_lst:
        thread = threading.Thread(target=process_file, args=(file, semaphore))
        thread.start()
        threads.append(thread)
    
    for thread in threads:
        thread.join()

root = TkinterDnD.Tk()
root.title('拖入文件夹以转换文件')
root.geometry('400x400')

# 创建输入变量的UI
frame = ttk.Frame(root, padding="10")
frame.pack(fill=tk.BOTH, expand=True)

ttk.Label(frame, text="请拖入包含 .bmson 文件的文件夹进行转换").pack(pady=20)

root.drop_target_register(DND_FILES)
root.dnd_bind('<<Drop>>', on_drop)

root.mainloop()