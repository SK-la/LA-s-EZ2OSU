#main.py
import json
import logging
import os
import pathlib
import shutil
import threading
from PyQt5 import QtWidgets, QtCore
from process_data import process_data
from osu import generate_osu_file

logging.basicConfig(level=logging.INFO)

output_base_path = pathlib.Path("output")
output_base_path.mkdir(exist_ok=True)

def get_unique_filename(existing_path):
    base, extension = existing_path.stem, existing_path.suffix
    counter = 1
    while existing_path.exists():
        existing_path = existing_path.with_name(f"{base}_old_{counter}{extension}")
        counter += 1
    return existing_path

def process_bmson_file(bmson_file):
    logging.info(f"Processing file: {bmson_file}")
    try:
        with bmson_file.open('r') as file:
            data = json.load(file)
        # 在这里处理 bmson 文件的数据
    except Exception as e:
        logging.error(f"Error reading bmson file: {e}")
        
def process_folder(folder_path):
    folder_path = pathlib.Path(folder_path).resolve()
    logging.info(f"Normalized folder path: {folder_path}")

    if not folder_path.exists():
        logging.error(f"Path does not exist: {folder_path}")
        return

    bmson_file = next(folder_path.glob("*.bmson"), None)
    if not bmson_file:
        logging.error("No .bmson file found in the folder")
        logging.info(f"Files in the folder: {list(folder_path.iterdir())}")  # 列出文件夹中的文件
        return

    logging.info(f"Processing file: {bmson_file}")
    try:
        with bmson_file.open('r') as file:
            data = json.load(file)
    except Exception as e:
        logging.error(f"Error reading bmson file: {e}")
        return
        
    try:
        info_obj, names_obj, osu_content, audio_name = process_data(data)
    
        # 创建输出文件夹
        output_base_path = folder_path.parent / names_obj.new_folder
        sub_folder_path = output_base_path / names_obj.sub_folder
        output_base_path.mkdir(parents=True, exist_ok=True)
        sub_folder_path.mkdir(parents=True, exist_ok=True)

        # 复制媒体文件到新文件夹
        files = scan_folder(folder_path)
        for file_path in files:
            file_path = pathlib.Path(file_path)
            if file_path.suffix in {'.mp3', '.wav', '.ogg', '.jpg', '.png'}:
                base_name = file_path.name
                #按新格式命名图片
                if file_path.suffix in {'.jpg', '.png'}:
                    mda_new_name = f"{info_obj.song}_{info_obj.diff}{file_path.suffix}"
                elif file_path.suffix in {'.wav', '.ogg'} and file.name in f"{audio_name}":
                    mda_new_name = f"{audio_name}{file_path.suffix}"
                else:
                    mda_new_name = base_name
                destination_path = sub_folder_path / mda_new_name
                    
                # 检查目标文件夹中是否存在重名文件
                if destination_path.exists():
                    existing_path = get_unique_filename(destination_path)
                    destination_path.rename(existing_path)

                shutil.copy(file_path, destination_path)
            
        
        # 重命名已有的 .osu 文件追加old后缀
        osu_file_path = sub_folder_path / names_obj.osu_filename
        if osu_file_path.exists():
            base, ext = osu_file_path.stem, osu_file_path.suffix
            counter = 1
            old_osu_filename = f"{base}_old{counter}{ext}"
            while (sub_folder_path / old_osu_filename).exists():
                counter += 1
                old_osu_filename = f"{base}_old{counter}{ext}"
            osu_file_path.rename(sub_folder_path / old_osu_filename)
                
        # 写入 osu 文件
        with osu_file_path.open('w') as file:
            file.write(osu_content)

    except Exception as e:
        logging.error(f"Error processing data: {e}")


def scan_folder(folder_path):
    files = []
    folder_path = os.path.normpath(folder_path)  # 规范化路径
    for root, _, filenames in os.walk(folder_path):
        root = os.path.normpath(root)  # 规范化路径
        for filename in filenames:
            file_path = os.path.join(root, filename)
            file_path = os.path.normpath(file_path)  # 规范化路径
            if os.path.isfile(file_path):
                files.append(file_path)
    return files

class FileDropWidget(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setAcceptDrops(True)
        self.initUI()

    def initUI(self):
        self.setWindowTitle('拖入文件夹以转换文件')
        self.setGeometry(100, 100, 400, 400)
        layout = QtWidgets.QVBoxLayout()
        label = QtWidgets.QLabel("请拖入包含 .bmson 文件的文件夹进行转换")
        layout.addWidget(label)
        self.setLayout(layout)

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.accept()
        else:
            event.ignore()

    def dropEvent(self, event):
        files_lst = []
        for url in event.mimeData().urls():
            path = pathlib.Path(url.toLocalFile())
            if path.exists():
                if path.is_file() and path.suffix == '.bmson':
                    files_lst.append(str(path))
                elif path.is_dir():
                    for root_dir, _, files in os.walk(path):
                        root_dir = pathlib.Path(root_dir)
                        for name in files:
                            file_path = root_dir / name
                            if file_path.suffix == '.bmson':
                                files_lst.append(str(file_path))

        semaphore = threading.BoundedSemaphore(value=min(len(files_lst), os.cpu_count() + 4, 10))
        threads = []
        for file in files_lst:
            thread = threading.Thread(target=process_folder, args=(file,))
            thread.start()
            threads.append(thread)
        
        for thread in threads:
            thread.join()

if __name__ == '__main__':
    app = QtWidgets.QApplication([])
    window = FileDropWidget()
    window.show()
    app.exec_()